# -*- coding: utf-8 -*-
"""PINN_Maxwell.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FkufPBtR4-s9yltZtBm9nXwMmWpeKTdq

# install deepxde
"""

!pip install deepxde

import deepxde as dde
import numpy as np
import matplotlib.pyplot as plt

R = 1

num_dense_layers = 10
num_dense_nodes = 275
lr = 0.003

def pde(x, y):
  du_xx = dde.grad.hessian(y, x, i=0, j=0)
  du_yy = dde.grad.hessian(y, x, i=1, j=1)

  return du_xx + du_yy

def boundary(x, on_boundary):
  return on_boundary

def boundary_top(x, on_boundary):
  return on_boundary and np.allclose(x, [0, 1])

def boundary_bottom(x, on_boundary):
  return on_boundary and np.allclose(x, [0, -1])

def boundary_left_right(x, on_boundary):
  return on_boundary and not boundary_top(x, on_boundary) and not boundary_bottom(x, on_boundary)

def boundary_d(x, on_boundary):
  return on_boundary and np.allclose(x, [0, 0])

geom = dde.geometry.Disk([0,0], R)

bc_top = dde.icbc.NeumannBC(geom, lambda x : 1 if boundary_top(x, True) else 0, boundary)
bc_bottom = dde.icbc.NeumannBC(geom, lambda x : -1 if boundary_bottom(x,True) else 0, boundary)
bc_round = dde.icbc.NeumannBC(geom, lambda x : 0 if boundary_left_right(x, True) else 0, boundary)
bc_d = dde.icbc.DirichletBC(geom, lambda x : 0 if boundary_d(x, True) else 0, boundary)

data = dde.data.PDE(geom, pde, [bc_top, bc_bottom, bc_round, bc_d], num_domain=3000, num_boundary=300, num_test=1500)

layer_size = [2] + [num_dense_nodes] * num_dense_layers + [1]
activation = 'sigmoid'
net = dde.nn.FNN(layer_size, activation, "Glorot uniform")
model = dde.Model(data, net)

model.compile("adam", lr=lr)
losshistory, train_state = model.train(iterations=10000)

dde.saveplot(losshistory, train_state, issave=True, isplot=True)

Nx = 100
Ny = 100

xmin, xmax, ymin, ymax = [-1, 1, -1, 1]
plot_gird = np.mgrid[xmin : xmax : Nx * 1j, ymin : ymax : Ny * 1j]
points = np.vstack(
    (plot_gird[0].ravel(), plot_gird[1].ravel(), np.zeros(plot_gird[0].size))
)

points_2d = points[:2,:]
u = model.predict(points[:2,:].T)
u = u.reshape((Nx, Ny))

ide = np.sqrt(points_2d[0, :]**2 + points_2d[1,:]**2) > R
ide = ide.reshape((Nx, Nx))

plt.rc("font", family="serif", size=22)

fig, ax1 = plt.subplots(1, sharey=True, figsize=(24,12))

matrix = np.fliplr(u).T
matrix = np.ma.masked_where(ide, matrix)

pcm = ax1.imshow(
    matrix,
    extent=[-1,1,-1,1],
    cmap=plt.cm.get_cmap("seismic"),
    interpolation="spline16",
    label="PINN",
)

fig.colorbar(pcm, ax=ax1)

ax1.set_title("PINNs")

plt.savefig("plot_manufactured.pdf")

import deepxde as dde
import numpy as np
import matplotlib.pyplot as plt
import skopt
from skopt import gp_minimize
from skopt.plots import plot_convergence, plot_objective
from skopt.space import Real, Categorical, Integer
from skopt.utils import use_named_args

np.int = int

R = 1

precision_train = 15
precision_test = 30
iterations = 10000

def pde(x, y):
  du_xx = dde.grad.hessian(y, x, i=0, j=0)
  du_yy = dde.grad.hessian(y, x, i=1, j=1)

  return du_xx + du_yy

def boundary(x, on_boundary):
  return on_boundary

def boundary_top(x, on_boundary):
  return on_boundary and np.allclose(x, [0, 1])

def boundary_bottom(x, on_boundary):
  return on_boundary and np.allclose(x, [0, -1])

def boundary_left_right(x, on_boundary):
  return on_boundary and not boundary_top(x, on_boundary) and not boundary_bottom(x, on_boundary)

def boundary_d(x, on_boundary):
  return on_boundary and np.allclose(x, [0, 0])



def creat_model(config):
  learning_rate, num_dense_layers, num_dense_nodes, activation = config

  geom = dde.geometry.Disk([0,0], R)
  bc_top = dde.icbc.NeumannBC(geom, lambda x : 1 if boundary_top(x, True) else 0, boundary)
  bc_bottom = dde.icbc.NeumannBC(geom, lambda x : -1 if boundary_bottom(x,True) else 0, boundary)
  bc_round = dde.icbc.NeumannBC(geom, lambda x : 0 if boundary_left_right(x, True) else 0, boundary)
  bc_d = dde.icbc.DirichletBC(geom, lambda x : 0 if boundary_d(x, True) else 0, boundary)

  nx_train = int(3000)
  nx_test = int(1500)

  data = dde.data.PDE(
      geom,
      pde,
      [bc_top, bc_bottom, bc_round, bc_d],
      num_domain=nx_train,
      num_boundary=int(nx_train/10),
      num_test=nx_test,
  )

  net = dde.maps.FNN(
      [2] + [num_dense_nodes] * num_dense_layers + [1],
      activation,
      "Glorot uniform",
  )

  model = dde.Model(data, net)
  model.compile("adam", lr=learning_rate)
  return model

def train_model(model, config):
  losshistory, train_state = model.train(iterations=iterations)
  train = np.array(losshistory.loss_train).sum(axis=1).ravel()
  test = np.array(losshistory.loss_test).sum(axis=1).ravel()

  error = test.min()
  return error

n_calls = 50
dim_learning_rate = Real(low=1e-4, high=5e-2, name="learning_rate", prior="log-uniform")
dim_num_dense_layers = Integer(low=1, high=10, name="num_dense_layers")
dim_num_dense_nodes = Integer(low=5, high=500, name="num_dense_nodes")
dim_activation = Categorical(categories=["sin", "sigmoid", "tanh"], name="activation")

dimensions = [
    dim_learning_rate,
    dim_num_dense_layers,
    dim_num_dense_nodes,
    dim_activation,
]

default_parameters = [1e-3, 4, 50, "tanh"]

@use_named_args(dimensions=dimensions)
def fitness(learning_rate, num_dense_layers, num_dense_nodes, activation):
  config = [learning_rate, num_dense_layers, num_dense_nodes, activation]
  global ITERATION

  print(ITERATION, "it number")
  print("learning rate : {0:.1e}".format(learning_rate))
  print("num_dense_layers:", num_dense_layers)
  print("num_dense_nodes:", num_dense_nodes)
  print("activation:", activation)
  print()

  model = creat_model(config)
  error = train_model(model, config)

  if np.isnan(error):
    error = 10**5

  ITERATION += 1
  return error

ITERATION = 0

search_result = gp_minimize(
    func=fitness,
    dimensions=dimensions,
    acq_func="EI",  # Expected Improvement.
    n_calls=n_calls,
    x0=default_parameters,
    random_state=1234,
)

print(search_result.x)

plot_convergence(search_result)
plot_objective(search_result, show_points=True, size=3.8)